#+TITLE: Data Sci Discover Project
# #+STARTUP: latexpreview
#+OPTIONS: broken-links:auto
#+INFOJS_OPT: view:showall toc:3
#+PLOT: title:"Citas" ind:1 deps:(3) type:2d with:histograms set:"yrange [0:]"
#+OPTIONS: tex:t
#+TODO: TODO IN-PROGRESS WAITING DONE
#+CATEGORY: DProj
:HTML:
#+INFOJS_OPT: view:info toc:3
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="style.css">
#+CSL_STYLE: /home/ryan/Templates/CSL/nature.csl
:END:
:R:
#+PROPERTY: header-args:R :session TADMain :dir ./ :cache yes :eval never-export :exports both
# exports: both (or code or whatever)
# results: table (or output or whatever)
:END:
:SlowDown:
# #+STARTUP: latexpreview
#+LATEX_HEADER: \usepackage{/home/ryan/Dropbox/profiles/Templates/LaTeX/ScreenStyle}
# #+LATEX_HEADER: \twocolumn
#+latex_header: \addbibresource{references.bib}
cite:kamvarAdaptiveMethodsComputation2004
* Links
- [[file:~/Dropbox/Notes/Org/ThinkingAboutData.org::+TITLE: Thinking About Data][Thinking About Data]]
- [[file:laparkPowerWalk2013.pdf][Paper]]
- [[file:Proposal/Propsal.org][Research Proposal]]
  [[file:ImplementingPageRank/01PageRank.Rmd::---][Preliminary Implementation]]


* Proposal

** Question

/Can we determine the second eigenvalue from the method parameters? For PageRank, the second eigenvalue is equal to the smoothing parameter \alpha/

#+begin_quote
Yes. An open question for the Power Walk method is, can we determine the second eigenvalue from the method parameters? For PageRank, the second eigenvalue is equal to the smoothing parameter \alpha. The second eigenvalue determines how long the algorithm takes to converge and how stable the solution is.
To begin, implement the method for computing PageRank and then the Power Walk. It can all be done using sparse matrices, so it only requires a fraction of the memory and is each iteration is quick.
#+end_quote

** Working

Take the exemplar Graph from Figure 1:


#+NAME: DotLib
#+CAPTION: Code to Generate DOT Graph
#+begin_src plantuml :output both :file ./Media/Example.png :exports both :eval never-export :eval never-export
# #+begin_src javascript :exports code
@startdot
strict digraph graphName {
concentrate=true
fillcolor=green
color=blue
style="filled, rounded"
 A [shape=box, fillcolor="#a31621", style="rounded, filled"]

 edge [
    arrowhead="none"
  ];

 node[
    fontname="Fira Code",
    shape="square",
    fixedsize=false,
    style=rounded
  ];


# A -> B [dir="both"]
A -> B
B [shape=box, fillcolor="#bfdbf7", style="rounded, filled"]
B -> A
C [shape=box, fillcolor="#eaf4d3", style="rounded, filled"]
C -> D
D [shape=box, fillcolor="#0f5257", style="rounded, filled"]
D -> C
}
@enddot
#+end_src

#+RESULTS: DotLib
[[file:./Media/Example.png]]



$$\begin{aligned}
    \Gamma =  I - n D^{- 1}_B \\
\end{aligned}$$

Where we have the following:

$$\begin{aligned}
    \beta &= 10 \\
    B &= \beta^A \\
    A &=
    \begin{bmatrix}
0& 1& 0& 0 \\
1& 0& 0& 0 \\
0& 0& 0& 1 \\
0& 0& 1& 0
    \end{bmatrix} \\
     \implies
    B &= \begin{bmatrix}
     10 & 1 & 1 & 1 \\
     1 & 10 & 1 & 1 \\
     1 & 1 & 10 & 1 \\
     1 & 1 & 1 & 10 \\
     \end{bmatrix}  \\
     \text{$D_B$ is a diagonal matrix of the column sums:}\\
     D &= \begin{bmatrix}
     13 & 0 & 0 & 0 \\
     0 & 13 & 0 & 0 \\
     0 & 0 & 13 & 0 \\
     0 & 0 & 0 & 13
     \end{bmatrix}  \\
     \text{Hence the Inverse is:}\\
     D_B^{-1}&= \frac{I}{13}\\
     \text{Putting it all together:}\\
     \Gamma &=  I - n D^{- 1}_B \\
     &= I - \frac{4 \cdot I}{13} \\
     &= \frac{9}{13} \cdot  I \\
     &= \begin{bmatrix}
         \frac{9}{13} & 0 & 0 & 0 \\
         0 & \frac{9}{13} & 0 & 0 \\
         0 & 0 & \frac{9}{13} & 0 \\
         0 & 0 & 0 &  \frac{9}{13}
     \end{bmatrix}  \\
     & \approx \begin{bmatrix}
         0.6923 & 0 & 0 & 0 \\
         0 & 0.6923 & 0 & 0 \\
         0 & 0 & 0.6923 & 0 \\
         0 & 0 & 0 & 0.6923
     \end{bmatrix}



\end{aligned}$$




\* References
This section is necessary for references to work in /HTML/ export, however it breaks LaTeX export because that relies on BibLaTex NOT BibTex which this is for.

Org-ref hasn't been updated to allow a way to use HTML references with the syntax for biblatex.

The Auto Sync is handled from inside

# ####### Delete these!!!!!
+<<bibliographystyle link>>
bibliographystyle:unsrt

<<bibliography link>>
bibliography:./references.bib
# ####### Delete these!!!!!

#+end_example

* Working
#+BEGIN_SRC R
  if (require("pacman")) {
      library(pacman)
    }else{
      install.packages("pacman")
      library(pacman)
    }
#+END_SRC

#+BEGIN_EXAMPLE
  ## Loading required package: pacman
#+END_EXAMPLE

#+BEGIN_SRC R
    pacman::p_load(tidyverse)
#+END_SRC

** Implementing Page Rank Method on a small graph
  :PROPERTIES:
  :CUSTOM_ID: implementing-page-rank-methods
  :END:

*** Example Graph
   :PROPERTIES:
   :CUSTOM_ID: example-graph
   :END:

Consider the following Graph taken from the paper:

#+BEGIN_SRC R
  g1 <- igraph::graph.formula(1++2, 1+-8, 1+-5, 2+-5, 2+-7, 2+-8, 2+-6, 2+-9, 3++4, 3+-5, 3+-6, 3+-9, 3+-10, 4+-9, 4+-10, 4+-5, 5+-8, 6+-8, 7+-8)
  plot(g1)
#+END_SRC

[[file:ImplementingPageRank/01PageRank_files/figure-html/unnamed-chunk-2-1.png]]

**** Adjacency Matrix
    :PROPERTIES:
    :CUSTOM_ID: adjacency-matrix
    :END:

The adjacency Matrix is given by:

#+BEGIN_SRC R
  A <- igraph::get.adjacency(g1, names = TRUE, sparse = FALSE) %>%
    as.matrix()

  ## Adjust the Order
  (A <- A[order(as.integer(row.names(A))), order(as.integer(colnames(A)))])
#+END_SRC

#+BEGIN_EXAMPLE
  ##    1 2 3 4 5 6 7 8 9 10
  ## 1  0 1 0 0 0 0 0 0 0  0
  ## 2  1 0 0 0 0 0 0 0 0  0
  ## 3  0 0 0 1 0 0 0 0 0  0
  ## 4  0 0 1 0 0 0 0 0 0  0
  ## 5  1 1 1 1 0 0 0 0 0  0
  ## 6  0 1 1 0 0 0 0 0 0  0
  ## 7  0 1 0 0 0 0 0 0 0  0
  ## 8  1 1 0 0 1 1 1 0 0  0
  ## 9  0 1 1 1 0 0 0 0 0  0
  ## 10 0 0 1 1 0 0 0 0 0  0
#+END_EXAMPLE

**** State Distribution
    :PROPERTIES:
    :CUSTOM_ID: state-distribution
    :END:

The state distribution is the transpose of the adjacency matrix:

#+BEGIN_SRC R
  (p0 <- t(A))
#+END_SRC

#+BEGIN_EXAMPLE
  ##    1 2 3 4 5 6 7 8 9 10
  ## 1  0 1 0 0 1 0 0 1 0  0
  ## 2  1 0 0 0 1 1 1 1 1  0
  ## 3  0 0 0 1 1 1 0 0 1  1
  ## 4  0 0 1 0 1 0 0 0 1  1
  ## 5  0 0 0 0 0 0 0 1 0  0
  ## 6  0 0 0 0 0 0 0 1 0  0
  ## 7  0 0 0 0 0 0 0 1 0  0
  ## 8  0 0 0 0 0 0 0 0 0  0
  ## 9  0 0 0 0 0 0 0 0 0  0
  ## 10 0 0 0 0 0 0 0 0 0  0
#+END_EXAMPLE

**** Probability Transition Matrix
    :PROPERTIES:
    :CUSTOM_ID: probability-transition-matrix
    :END:

The probability transition matrix is such that each column of the
initial state distribution (i.e.Â the transposed adjacency matrix) is
scaled to 1.

#+BEGIN_SRC R
  p0 %*% diag(1/colSums(p0))
#+END_SRC

#+BEGIN_EXAMPLE
  ##    [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]      [,9] [,10]
  ## 1     0    1    0    0 0.25  0.0    0  0.2 0.0000000   0.0
  ## 2     1    0    0    0 0.25  0.5    1  0.2 0.3333333   0.0
  ## 3     0    0    0    1 0.25  0.5    0  0.0 0.3333333   0.5
  ## 4     0    0    1    0 0.25  0.0    0  0.0 0.3333333   0.5
  ## 5     0    0    0    0 0.00  0.0    0  0.2 0.0000000   0.0
  ## 6     0    0    0    0 0.00  0.0    0  0.2 0.0000000   0.0
  ## 7     0    0    0    0 0.00  0.0    0  0.2 0.0000000   0.0
  ## 8     0    0    0    0 0.00  0.0    0  0.0 0.0000000   0.0
  ## 9     0    0    0    0 0.00  0.0    0  0.0 0.0000000   0.0
  ## 10    0    0    0    0 0.00  0.0    0  0.0 0.0000000   0.0
#+END_EXAMPLE

***** Create a Function
     :PROPERTIES:
     :CUSTOM_ID: create-a-function
     :END:

#+BEGIN_SRC R
  adj_to_probTrans <- function(adjMat) {
    t(adjMat) %*% diag(1/colSums(t(adjMat)))
  }

  (T <- adj_to_probTrans(A)) %>% round(2)
#+END_SRC

#+BEGIN_EXAMPLE
  ##    [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
  ## 1     0    1    0    0 0.25  0.0    0  0.2 0.00   0.0
  ## 2     1    0    0    0 0.25  0.5    1  0.2 0.33   0.0
  ## 3     0    0    0    1 0.25  0.5    0  0.0 0.33   0.5
  ## 4     0    0    1    0 0.25  0.0    0  0.0 0.33   0.5
  ## 5     0    0    0    0 0.00  0.0    0  0.2 0.00   0.0
  ## 6     0    0    0    0 0.00  0.0    0  0.2 0.00   0.0
  ## 7     0    0    0    0 0.00  0.0    0  0.2 0.00   0.0
  ## 8     0    0    0    0 0.00  0.0    0  0.0 0.00   0.0
  ## 9     0    0    0    0 0.00  0.0    0  0.0 0.00   0.0
  ## 10    0    0    0    0 0.00  0.0    0  0.0 0.00   0.0
#+END_EXAMPLE

*** Page Rank Random Surfer
   :PROPERTIES:
   :CUSTOM_ID: page-rank-random-surfer
   :END:

The random surfer page rank method modifies the probability transition
matrix $T$ so that the method works also for non-ergodic graphs by
introducing the possibility of a random jump, we'll call the surfer
transition matrix $S$:

\begin{align}
    S &= \lambda T +  \left( 1- \lambda \right)B :\\
\ \\
    B&= \begin{bmatrix}
    \frac{1}{N} & \frac{1}{N} & \ldots & \frac{1}{N} \\
    \frac{1}{N} & \frac{1}{N} & \ldots & \frac{1}{N} \\
        \vdots      & \vdots      & \ddots & \vdots \\
    \frac{1}{N} & \frac{1}{N} & \ldots & \frac{1}{N} \\
    \end{bmatrix}  \\
    N&= \left| \left| V \right| \right| \\
    \lambda &\in [0,1]
\end{align}

#+BEGIN_SRC R
  B <- matrix(rep(1/nrow(T), length.out = nrow(T)**2), nrow = nrow(T))
  l <- 0.8

  S <- l*T+(1-l)*B
#+END_SRC

**** Eigen Value Method
    :PROPERTIES:
    :CUSTOM_ID: eigen-value-method
    :END:

The eigenvector corresponding to the the eigenvalue of 1 will be the
stationary point:

#+BEGIN_SRC R
  eigen(S, symmetric = FALSE)
#+END_SRC

#+BEGIN_EXAMPLE
  ## eigen() decomposition
  ## $values
  ##  [1]  1.000000e+00  8.000000e-01 -8.000000e-01 -8.000000e-01  3.117428e-09
  ##  [6] -3.117428e-09  1.233252e-17 -6.831762e-18  1.351981e-18  1.827902e-34
  ##
  ## $vectors
  ##              [,1]          [,2]          [,3]          [,4]          [,5]
  ##  [1,] -0.48531271  5.000000e-01  1.074642e-03  7.070996e-01  6.735753e-01
  ##  [2,] -0.52732002  5.000000e-01 -1.074642e-03 -7.070996e-01  9.622505e-02
  ##  [3,] -0.49152601 -5.000000e-01  7.071060e-01  3.197134e-03  9.622505e-02
  ##  [4,] -0.47977477 -5.000000e-01 -7.071060e-01 -3.197134e-03  2.886751e-01
  ##  [5,] -0.05288058  7.620569e-17  1.212133e-16 -3.419297e-18 -3.849002e-01
  ##  [6,] -0.05288058  7.620569e-17 -7.099634e-17 -3.419297e-18 -3.849002e-01
  ##  [7,] -0.05288058  7.620569e-17  2.943750e-17 -3.419297e-18 -3.849002e-01
  ##  [8,] -0.04558671  6.926804e-17 -1.948070e-18 -4.183296e-17 -7.499367e-09
  ##  [9,] -0.04558671  6.926804e-17  7.359376e-18 -4.183296e-17 -7.499367e-09
  ## [10,] -0.04558671  6.926804e-17  7.359376e-18 -4.183296e-17 -7.499367e-09
  ##                [,6]          [,7]          [,8]          [,9]         [,10]
  ##  [1,] -6.735753e-01 -2.658112e-01  5.357798e-01 -4.171123e-01  2.122431e-01
  ##  [2,] -9.622504e-02  1.896313e-01 -1.330801e-01 -7.334472e-02  1.241240e-01
  ##  [3,] -9.622504e-02  1.990137e-01 -1.665251e-01  2.591495e-01 -1.598069e-04
  ##  [4,] -2.886751e-01 -3.972519e-02  1.099005e-02 -1.886035e-02  6.690506e-02
  ##  [5,]  3.849002e-01 -7.585250e-01  5.323206e-01  2.933789e-01 -4.964959e-01
  ##  [6,]  3.849002e-01  4.774778e-01 -3.550303e-01  5.560197e-01 -1.341297e-01
  ##  [7,]  3.849002e-01  2.204565e-01 -5.047228e-01  1.987554e-01  1.561493e-01
  ##  [8,] -7.499367e-09 -1.208463e-16  1.668414e-16 -2.685569e-16  3.416862e-17
  ##  [9,] -7.499367e-09 -1.125898e-02  4.013399e-02 -3.989931e-01 -5.316106e-01
  ## [10,] -7.499367e-09 -1.125898e-02  4.013399e-02 -3.989931e-01  6.029746e-01
#+END_EXAMPLE

So in this case +the+ a stationary point is
$\langle -0.49, -0.53, -0.49, -0.48, -0.05, -0.05, -0.05, -0.04, -0.04, -0.04 \rangle$

which can be verified:

$$
1 \vec{p} = S\vec{p}
$$

#+BEGIN_SRC R
  (p     <- eigen(S)$values[1] * eigen(S)$vectors[,1])
#+END_SRC

#+BEGIN_EXAMPLE
  ##  [1] -0.48531271 -0.52732002 -0.49152601 -0.47977477 -0.05288058 -0.05288058
  ##  [7] -0.05288058 -0.04558671 -0.04558671 -0.04558671
#+END_EXAMPLE

#+BEGIN_SRC R
  (p_new <- S %*% p)
#+END_SRC

#+BEGIN_EXAMPLE
  ##           [,1]
  ## 1  -0.48531271
  ## 2  -0.52732002
  ## 3  -0.49152601
  ## 4  -0.47977477
  ## 5  -0.05288058
  ## 6  -0.05288058
  ## 7  -0.05288058
  ## 8  -0.04558671
  ## 9  -0.04558671
  ## 10 -0.04558671
#+END_EXAMPLE

However this vector does not sum to 1 so the scale should be adjusted
(for probabilities the vector should sum to 1):

#+BEGIN_SRC R
  (p_new <- p_new/sum(p_new))
#+END_SRC

#+BEGIN_EXAMPLE
  ##         [,1]
  ## 1  0.2129185
  ## 2  0.2313481
  ## 3  0.2156444
  ## 4  0.2104889
  ## 5  0.0232000
  ## 6  0.0232000
  ## 7  0.0232000
  ## 8  0.0200000
  ## 9  0.0200000
  ## 10 0.0200000
#+END_EXAMPLE

**** Power Value Method
    :PROPERTIES:
    :CUSTOM_ID: power-value-method
    :END:

Using the power method should give the same result, which it indeed
does, but for the scale:

#+BEGIN_SRC R
  p_new <- p_new *123456789

  while (sum(round(p, 9) != round(p_new, 9))) {
      (p     <- p_new)
      (p_new <- S %*% p)
  }

  p_new
#+END_SRC

#+BEGIN_EXAMPLE
  ##        [,1]
  ## 1  26286237
  ## 2  28561500
  ## 3  26622771
  ## 4  25986282
  ## 5   2864198
  ## 6   2864198
  ## 7   2864198
  ## 8   2469136
  ## 9   2469136
  ## 10  2469136
#+END_EXAMPLE

#+BEGIN_SRC R
  p
#+END_SRC

#+BEGIN_EXAMPLE
  ##        [,1]
  ## 1  26286237
  ## 2  28561500
  ## 3  26622771
  ## 4  25986282
  ## 5   2864198
  ## 6   2864198
  ## 7   2864198
  ## 8   2469136
  ## 9   2469136
  ## 10  2469136
#+END_EXAMPLE

This answer is however identical in direction, if it scaled to 1 the
same value will be returned:

#+BEGIN_SRC R
  (p_new <- p_new/sum(p_new))
#+END_SRC

#+BEGIN_EXAMPLE
  ##         [,1]
  ## 1  0.2129185
  ## 2  0.2313481
  ## 3  0.2156444
  ## 4  0.2104889
  ## 5  0.0232000
  ## 6  0.0232000
  ## 7  0.0232000
  ## 8  0.0200000
  ## 9  0.0200000
  ## 10 0.0200000
#+END_EXAMPLE

**** Scaling
    :PROPERTIES:
    :CUSTOM_ID: scaling
    :END:

However if the initial state sums to 1, then the scale of the stationary
vector will also sum to 1.

#+BEGIN_SRC R
  p     <- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  p_new <- S %*% p

  while (sum(round(p, 9) != round(p_new, 9))) {
      (p     <- p_new)
      (p_new <- S %*% p)
  }

  cbind(p_new, p)
#+END_SRC

#+BEGIN_EXAMPLE
  ##         [,1]      [,2]
  ## 1  0.2129185 0.2129185
  ## 2  0.2313481 0.2313481
  ## 3  0.2156444 0.2156444
  ## 4  0.2104889 0.2104889
  ## 5  0.0232000 0.0232000
  ## 6  0.0232000 0.0232000
  ## 7  0.0232000 0.0232000
  ## 8  0.0200000 0.0200000
  ## 9  0.0200000 0.0200000
  ## 10 0.0200000 0.0200000
#+END_EXAMPLE
** Implementing Page Rank on a much Larger Graph
